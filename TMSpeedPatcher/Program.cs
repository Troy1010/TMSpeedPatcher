using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Oblivion;
using Mutagen.Bethesda.Plugins.Exceptions;
using Noggog;

namespace TMSpeedPatcher
{
    public class Program
    {
        private static Lazy<Settings> _settings = null!;
        private static Settings Settings => _settings.Value;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IOblivionMod, IOblivionModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.Oblivion, "YourPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            Console.WriteLine("\n\nInitialization successful, beginning patcher process...\n");
            var count = 0;
            // NPCs
            foreach (var oldNpc in state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>())
            {
                try
                {
                    if (oldNpc.Stats?.Speed == null || oldNpc.EditorID == null)
                        continue;

                    var newNpc = oldNpc.DeepCopy();
                    
                    if (Settings.NpcBlacklist.Contains(newNpc))
                        Console.WriteLine($"Found NpcBlacklist EditorID:{oldNpc.EditorID} Name:{oldNpc.Name} id:{oldNpc.FormKey.ModKey.FileName}`{oldNpc.FormKey.IDString()}");

                    if (newNpc.Stats?.Speed == null || newNpc.Stats.Speed <= 1)
                        continue;
                    
                    newNpc.Stats.Speed = (byte)CalcSpeed(newNpc.Stats.Speed);

                    state.PatchMod.Npcs.Set(newNpc);
                    Console.WriteLine($"Successfully modified npc. EditorID:{newNpc.EditorID} Name:{newNpc.Name}");
                    ++count;
                    Console.WriteLine($"\tOldSpeed:{oldNpc.Stats.Speed} NewSpeed:{newNpc.Stats.Speed}\n");
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, oldNpc);
                }
            }
            // Creatures
            foreach (var oldCreature in state.LoadOrder.PriorityOrder.WinningOverrides<ICreatureGetter>())
            {
                try
                {
                    if (oldCreature.Data?.Speed == null || oldCreature.EditorID == null)
                        continue;

                    var newCreature = oldCreature.DeepCopy();

                    if (Settings.CreatureBlacklist.Contains(newCreature))
                        Console.WriteLine($"Found CreatureBlacklist EditorID:{oldCreature.EditorID} Name:{oldCreature.Name} id:{oldCreature.FormKey.ModKey.FileName}`{oldCreature.FormKey.IDString()}");
                
                    if (newCreature.Data?.Speed == null || newCreature.Data.Speed <= 1 || Settings.CreatureBlacklist.Contains(newCreature))
                        continue;
                    
                    newCreature.Data.Speed = (byte)CalcSpeed(newCreature.Data.Speed);

                    state.PatchMod.Creatures.Set(newCreature);
                    Console.WriteLine($"Successfully modified creature. EditorID:{oldCreature.EditorID} Name:{oldCreature.Name} id:{oldCreature.FormKey.ModKey.FileName}`{oldCreature.FormKey.IDString()}");
                    ++count;
                    Console.WriteLine($"\tOldSpeed:{oldCreature.Data.Speed} NewSpeed:{newCreature.Data.Speed}\n");
                }
                catch (Exception ex)
                {
                    throw RecordException.Enrich(ex, oldCreature);
                }
            }

            Console.WriteLine($"\nFinished patching {count} records.\n");
        }

        private static uint CalcSpeed(uint speed)
        {
            var speedRedefined = (float)speed;
            
            if (Settings.SpeedMult != 0)
            {
                speedRedefined *= Settings.SpeedMult;
                Console.WriteLine($"speed after mult:{speedRedefined}");
            }

            return (uint)Math.Max(1, speedRedefined.ToInt());
        }
    }
}
